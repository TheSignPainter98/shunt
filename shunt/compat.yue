local *

detect_host = ->
  if collectgarbage?
    'native'
  else
    'minecraft'
export HOST = detect_host!
export LUA = 'luajit'

compat_applied = false
export apply_compat = ->
  compat_applied = true

  table.unpack ??= assert unpack, 'internal error: cannot find unpack function'

  os.sleep ??= (n_secs) ->
    os.execute "sleep #{n_secs}s"

  os.tmpname ??= ->
    while true
      f = "lua_#{'%x'\format math.random 1, 100000}"
      with? io.open f, 'r'
        \close!
        continue
      return f

  os.remove ??= (path) ->
    try
      fs.delete path
      return true
    catch _
      return false

  os.rename ??= (src, dest) ->
    fs.move src, dest

  os.exit ??= (code) ->
    error "EXIT(#{code})"

  if not fs?
    global fs = {}

  fs.makeDir ??= (path) ->
    os.execute "mkdir -p '#{path}'"

  fs.getFreeSpace ??= (path) ->
    1000000

  fs.getCapacity ??= (path) ->
    1000000

  fs.list ??= (dir) ->
    assert (not dir\match "'"), "cannot list directory containing quote mark '#{dir}'"
    with {}
      p = assert io.popen "ls -1 '#{dir}'"
      line = p\read '*l'
      while line?
        [] = line
        line = p\read '*l'
      p\close!

  if not shell?
    global shell = {}

  shell.execute ??= (...) ->
    for i = 1, select '#', ...
      assert 'string' == type select i, ...

    args = [ "'#{arg}'" for arg in *{ LUA, ... } ]
    rc = os.execute table.concat args, ' '
    rc == 0

  bit.lshift ??= bit.blshift

  if not textutils?
    global textutils = {}

  is_list = (t) ->
    max_key = -1
    for k, _ in pairs t
      if 'number' != type k
        return false
      if k % 1 != 0
        return false
      if k > max_key
        max_key = k
    #t == max_key

  textutils.serialise ??= (value, opts) ->
    if not opts?
      error 'textutils.serialise must be called with compact:true'
    if opts.compact != true
      error 'textutils.serialise must be called with compact:true'
    if opts.allow_repetitions?
      error 'textutils.serialise must not be called with allow_repetitions'

    table.concat with {}
      serialise = (value) ->
        switch type value
          when 'nil'
            [] = 'null'
          when 'boolean', 'number'
            [] = tostring value
          when 'string'
            [] = '"'
            [] = value\gsub '"', '\\"'
            [] = '"'
          when 'table'
            if is_list value
              [] = '['
              first = true
              for e in *value
                if first
                  first = false
                else
                  [] = ','
                serialise e
              [] = ']'
            else
              [] = '{'
              first = true
              for k, v in pairs value
                if first
                  first = false
                else
                  [] = ','
                serialise k
                [] = ':'
                serialise v
              [] = '}'
          else
            error "cannot serialise a #{type value} as json"
      serialise value

  textutils.deserialise ??= (raw) ->
    print "deserialising '#{raw}'..."
    index = 1
    deserialise = ->
      if token = raw\match '^null', index
        print 'n'
        index += #token
        nil
      else if token = raw\match '^true', index
        print 't'
        index += #token
        true
      else if token = raw\match '^false', index
        print 'f'
        index += #token
        false
      else if number = raw\match '^[0-9]+%.[0-9]+', index
        print 'n'
        index += #number
        tonumber number
      else if number = raw\match '^[0-9]+', index
        print 'n'
        index += #number
        tonumber number
      else if string = raw\match '^"([^"]*)"', index
        print 's'
        index += 2 + #string
        string
      else if token = raw\match '^%[', index
        print 'l'
        index += 1
        with {}
          first = true
          while not raw\match '^]', index
            if first
              first = false
            else if raw\match '^,', index
              index += 1
            else
              error "expected `,` at position #{index}"
            print 'inner'
            [] = deserialise!
          index += 1
      else if raw\match '^{', index
        print 'm'
        with {}
          index += 1
          first = true
          while not raw\match '^}', index
            if first
              first = false
            else if raw\match '^,', index
              index += 1
            else
              error "expected `,` at position #{index}"

            key = deserialise!
            if raw\match '^:', index
              index += 1
            else
              error "expected `:` at position #{index}"
            [key] = deserialise!
          index += 1
      else
        error "unexpected character #{raw\sub index, index} at #{index}"
    ret = deserialise!
    print tostring ret
    if #raw != index - 1
      error "deserialisation ended early (parsed #{index} of #{#raw})"
    ret

export test_compat = ->
  if not compat_applied
    error 'call apply_compat before testing compat'
  tests =
    * name: 'os.tmpname returns a string'
      check: ->
        assert 'string' == type os.tmpname!
    * name: 'os.remove removes files',
      check: ->
        TEST_FILE = '.test_file_hj4k3h5jio'
        with? io.open TEST_FILE, 'r'
          \close!
          error "test file '#{TEST_FILE}' already exists, please remove it"
        with assert io.open TEST_FILE, 'w+'
          \close!
        with assert io.open TEST_FILE, 'r'
          \close!
        os.remove TEST_FILE
        with? io.open TEST_FILE, 'r'
          \close!
          error "expected test file '#{TEST_FILE}' to have been removed after calling os.remove"
    * name: 'HOST is unchanged'
      check: ->
        host = detect_host!
        if HOST != host
          error "host detection heuristic changed"
    * name: 'json roundtrip'
      check: ->
        case = (value, check) ->
          check ??= (v) ->
            assert v == value, "expected #{value} but got #{v}"
          check textutils.deserialise textutils.serialise value, compact: true
        case nil
        case { '123', '321' }, (v) ->
          assert v[1] == '123', "v[1] incorrect: #{v[1]}"
          assert v[2] == '321', "v[2] incorrect: #{v[2]}"
        case {
          world: 'how'
          ['hell\\o']: 123
          are: true
          you: false
        }, (v) ->
          assert v.world == 'how', "v.world incorrect: #{v.world}"
          assert v['hell\\o'] == 123, "v.hello incorrect: #{v['hell\\o']}"
          assert v.are == true, "v.are incorrect: #{v.are}"
          assert v.you == false, "v.you incorrect: #{v.you}"
    * name: 'textutils.deserialise deserialises'
      check: ->
  failed = false
  for test in *tests
    try
      test.check!
    catch err
      print "* test '#{test.name}' failed:\n  #{err}"
      failed = true
  if failed
    error 'some compatibility checks failed'
