local *

import 'compat' as :HOST
import 'quicktype' as :declare_singleton_type, :declare_type, :F, :T
import 'spec' as :spec

FORMAT_VERSION = 1
MIN_PAGE_SIZE = 1024

macro failure_marker = -> 'FAILURE_MARKER'
macro declare_failure_point = (tag) ->
  if not _G.failure_points?
    global failure_points = {}
  if failure_points[tag]
    error "failure point '#{tag}' redeclared"
  failure_points[tag] = true

  lines =
    * 'injected_failures ??= @_injected_failures'
    * "if injected_failures? and injected_failures[#{tag}]"
    * "  error '#{$failure_marker}'"
  table.concat lines, '\n'
macro known_failure_points = ->
  if not _G.failure_points?
    global failure_points = {}
  seen = {}
  table.concat with {}
    [] = '{'
    first = true
    tags = [ tag for tag, _ in pairs failure_points ]
    table.sort tags
    for tag in *tags
      if first
        first = false
      else
        [] = ','
      [] = '['
      [] = tag
      [] = ']: true'
    [] = '}'

declare_type 'writelite.Writelite', [[{
  mode: (writelite.Mode) => Self,
  page_size: (number) => Self,
  open: () => <boolean, ?string>,
  transaction: ((writelite.Transaction) -> <>) => <>,
  close: () => <boolean, ?string>,
}]]
declare_type 'writelite.Mode', '"blob"'
declare_type 'writelite.MainHeader', [[{
  format_version: number,
  page_size: number,
  mode: writelite.Mode,
}]]
export class Writelite
  @_open_transactions: T '{string}', {}

  new: F '(string, ?writelite.Fs) => <>', (@_path, @_fs=OsFs!) =>
    @_journal_path = T 'string', @_path .. '~'
    @_main_file = T '?writelite.File', nil
    @_open = T 'boolean', false
    @_mode = T '?writelite.Mode', nil
    @_page_size = 4096
    @_page_size_set = T 'boolean', false
    @_injected_failures = T '?{string}', nil

  mode: F '(writelite.Mode) => Self', (mode) =>
    if @_mode?
      error "cannot change mode once set"
    @_mode = mode
    @

  page_size: F '(number) => Self', (page_size) =>
    if @_page_size_set
      error "cannot change page size once set"
    if page_size < MIN_PAGE_SIZE
      error "cannot change page size to #{page_size}: minimum is #{MIN_PAGE_SIZE}"
    if page_size % 1 != 0
      error "cannot change page size to #{page_size}: not an integer"

    -- Assert `page_size` is a power of two.
    shifted = page_size
    while 0 == bit.band shifted, 1
      shifted = bit.brshift shifted, 1
    if shifted > 1
      error "cannot change page size to #{page_size}: not a power of 2"

    @_page_size_set = true
    @_page_size = page_size
    @

  open: F '() => <boolean, ?string>', =>
    if @_open
      return false, 'cannot open writelite file twice'
    @_open = true

    if not @_mode?
      return false, 'cannot open main file: mode unspecified'

    main_file, err = @_fs\open @_path, 'w+'
    if err?
      return false, "cannot open main file: #{err}"
    main_file\setvbuf 'full' -- Minimise writes.
    main_is_empty = do
      end_index, err = main_file\seek 'end', 0
      if err?
        return false, "cannot seek in main file: #{err}"
      _, err = main_file\seek 'set', 0
      if err?
        return false, "cannot seek in main file: #{err}"
      end_index == 0
    @_main_file = main_file

    -- if journal, _ = @_fs\open @_journal_path, 'r'
    --   journal_content = journal\read '*a'
    --   journal\close!
    --
    --   if @_journal_valid journal_content
    --     @_recover_journal @_main_file, journal_content
    --   else
    --     -- Discard incomplete transaction.
    --     os.remove @_journal_path

    local main_header
    if main_is_empty
      main_header = @_make_main_header!
      err = @_format_main main_header
      if err?
        return false, err
    else
      main_header, err = @_read_main_header!
      if err?
        return false, "cannot open writelite file: #{err}"
    @_main_header = main_header

    true, nil

  _make_main_header: F '() => writelite.MainHeader', =>
    header = T 'writelite.MainHeader',
      format_version: FORMAT_VERSION
      page_size: @_page_size
      mode: @_mode
      checksum: 0 -- Placeholder

    checksum = Hasher::hash header

    header.checksum = checksum
    header

  _read_main_header: F '() => <?writelite.MainHeader, ?string>', =>
    @_main_file\seek 'set', 0
    raw_header, err = @_main_file\read MIN_PAGE_SIZE
    if err?
      return nil, err
    header = (Deserialiser raw_header\sub #@_main_prelude!)
      \parse!

    checkers =
      format_version: (fv) -> if fv != FORMAT_VERSION
        "format version mismatch"
      mode: (m) -> if m != @_mode
        "mode mismatch"
      page_size: (ps) -> if ps != @_page_size
        "page size mismatch"
      checksum: ->
    for key, value in pairs header
      checker = checkers[key]
      if not checker?
        error "internal error: no such checker '#{key}'"
      err = checker value
      if err?
        return nil, "cannot open #{@_path}: #{err}"

    stored_checksum = header.checksum
    header.checksum = 0
    computed_checksum = Hasher::hash header
    if stored_checksum != computed_checksum
      return nil, "header corrupt (computed_checksum=#{computed_checksum}, stored_checksum=#{stored_checksum})"
    header.checksum = stored_checksum

    header

  _format_main: F '(writelite.MainHeader) => ?string', (header) =>
    fragments =
      * @_main_prelude!
      * Serialiser::serialise header

    current_size = 0
    for fragment in *fragments
      current_size += #fragment
    fragments[] = '\0'\rep MIN_PAGE_SIZE - current_size

    to_write = table.concat fragments
    if #to_write > MIN_PAGE_SIZE
      error "internal error: first page too large: #{#to_write} > #{MIN_PAGE_SIZE}"
    _, err = @_main_file\write to_write
    if err?
      return err
    _, err = @_main_file\flush!
    err

  _journal_valid: F '(string) => <>', (journal_content) =>
    -- TODO(kcza): read the prelude (must be the unedited prefix)
    -- TODO(kcza): read the header
    -- TODO(kcza): read the content, compute the hash, compare the hash
    error 'todo'

  _recover_journal: F '() => <>', =>
    -- TODO(kcza): Read the page map
    -- TODO(kcza): Read the pages
    -- TODO(kcza): Write the pages once mapped
    -- TODO(kcza): DO NOT DELETE THE JOURNAL! THIS NEEDS TO BE DONE AFTER THE DB IS READ TO ALLOW APPROPRIATE CRASHES!
    error 'todo'

  transaction: F '((writelite.Transaction) -> <>) => <>', (f) =>
    @@_open_transactions[@_path] = true

    txn = Transaction @_main_file, @_journal_path
    err = nil
    try
      f txn
    catch err2
      err = err2
      txn\abort!
    txn\_close!

    @@_open_transactions[@_path] = nil

    if err?
      error err
    return

  close: F '() => <boolean, ?string>', =>
    file_closure_error = @_main_file\close!

    if @@_open_transactions[@_path]
      return false, 'cannot close writelite file whilst transaction is open'

    if not @_open
      return false, 'cannot close writelite file: not open'
    @_open = false

    not file_closure_error?, file_closure_error

  _main_prelude: F '() => string', =>
    @_cached_main_prelude ??= table.concat
      * '\n'
      * '\n'
      * '\n'
      * '\n'
      * 'STOP!\n'
      * '\n'
      * 'DO NOT EDIT!\n'
      * '\n'
      * 'Editing this file will corrupt the database.\n'
      * '\n'
      * 'Close this file and DO NOT SAVE any changes.\n'
      * '\n'
      * 'EXIT the editor NOW.\n'
      * '\n'
      * '\n'
      * '\n'
      * '\n'
      * '-'\rep 49
      * '\n'
    @_cached_main_prelude

  _journal_prelude: F '() => string', =>
    @_cached_journal_prelude ??= do
      prelude_fragments =
        * '\n'
        * '\n'
        * '\n'
        * '\n'
        * 'STOP!\n'
        * '\n'
        * 'DO NOT EDIT!\n'
        * '\n'
        * 'Editing this file will cause data-loss.\n'
        * '\n'
        * 'Close this file and DO NOT SAVE any changes.\n'
        * '\n'
        * 'EXIT the editor NOW.\n'
        * '\n'
        * '\n'
        * '\n'
        * '\n'
      prelude_len = 0
      for line in *prelude_fragments
        prelude_len += #line

      spacer_line = ('.'\rep 49) .. '\n'
      while prelude_len < PAGE_SIZE - #spacer_line
        prelude_fragments[] = spacer_line
        prelude_len += #spacer_line
      while prelude_len < PAGE_SIZE - 2
        prelude_fragments[] = '.'
        prelude_len += #'\n'
      prelude_fragments[] = '@'
      prelude_fragments[] = '\n'

      prelude = table.concat prelude_fragments
      assert #prelude == PAGE_SIZE
      prelude
    @_cached_journal_prelude

  @_zero_page: F '() => string', =>
    @_cached_zero_page ??= '\0'\rep @_page_size
    @_cached_zero_page

  _ut_inject_failures: F '(?{string}) => <>', (@_injected_failures) =>

declare_type 'writelite.Fs', [[{
  open: (string, writelite.FileMode) => <?writelite.File, ?string>
}]]
declare_type 'writelite.FileMode', '"r"|"w"|"a"|"r+"|"w+"|"a+"'
declare_type 'writelite.File', [[~{
  read: ("*a"|number) => <?string, ?string>,
  write: (string) => ?string,
  seek: (Whence, ?number) => <?number, ?string>,
  setvbuf: ("full") => <>,
  flush: () => <boolean, ?string>,
  close: () => ?string,
}]]
class OsFs
  new: F '(?string) => <>', (@dir='.') =>

  open: F '(string, writelite.FileMode) => <?writelite.File, ?string>', (path, mode) =>
    io.open path, mode

declare_type 'writelite.Transaction', [[{
  write: (string) => <>,
  seek: (Whence, ?number) => <?number, ?string>,
  abort: () => <>,
}]]
declare_type 'Whence', '"set"|"cur"|"end"'
class Transaction
  new: F '(writelite.Writelite) => <>', (@_parent) =>
    @_pages = T '[writelite.Page]', {}
    @_len = T 'number', 0
    @_cursor = T 'number', 0
    @_aborted = T 'boolean', false
    @_page_size = @_parent._page_size

  write: F '(string) => <>', (bytes) =>
    if @_aborted
      error 'cannot write to aborted transaction'

    @_len += #bytes
    new_pages = {}
    if #bytes == @_page_size
      @_pages[] = bytes
      @_cursor += @_page_size
    else
      for bytes_offset = 0, #bytes, @_page_size
        new_page = Page @_cursor, bytes\sub 1 + bytes_offset, 1 + bytes_offset + @_page_size
        new_pages[] = new_page
        @_pages[] = new_page
        @_cursor += @_page_size

  seek: F '(Whence, ?number) => <>', (whence, offset) =>
    if @_aborted
      error 'cannot seek in aborted transaction'

    local new_cursor
    switch whence
      when 'set'
        new_cursor = offset ?? 0
        if new_cursor < 0
          error "cannot seek to negative position"
      when 'cur'
        assert offset?, 'internal error: "cur"-whence requires offset'
        new_cursor += offset
      when 'end'
        assert not offset?, 'internal error: "end"-whence cannot have no offset'
        new_cursor = @_len
      else
        error 'internal error: unreachable'
    new_cursor += @_page_size -- Account for header
    @_cursor = new_cursor

  abort: F '() => <>', =>
    @_aborted = true

  _close: F '() => <>', =>
    if @_aborted
      os.remove @_journal_path
      return

    -- Create and write to journal.
    with assert io.open @_journal_path, 'w+'
      assert \setvbuf 'full' -- Minimise writes.
      assert \seek 'set', 0
      assert \write ZERO_PAGE

      -- Write pages.
      for page in *@_pages
        assert \seek 'set', page._offset
        assert \write page._content

      -- Write header.
      assert \seek 'set', 0
      assert \write @_journal_header!

      assert \close!

    -- Write to main file.
    for page in *@_pages
      @_main_file\seek 'set', page._offset
      @_main_file\write page._content
    @_main_file\flush!

    -- Delete journal.
    os.remove @_journal_path

  _journal_header: F '() => string', =>
    content_hasher = Hasher!
    for page in *@_pages
      content_hasher\write page._content
    content_hash = content_hasher\finish!

    payload = Deserialiser
      :content_hash
    journal_hash = Hasher!
      \write JOURNAL_PRELUDE
      \write payload
      \finish!

    table.concat
      * JOURNAL_PRELUDE
      * encode_number journal_hash
      * encode_number #payload
      * payload

NIL_TAG = 0
NIL_TAG_CHAR = string.char NIL_TAG
TRUE_TAG = 1
TRUE_TAG_CHAR = string.char TRUE_TAG
FALSE_TAG = 2
FALSE_TAG_CHAR = string.char FALSE_TAG
INT_TYPE = 3
FLOAT_TYPE = 4
FLOAT_TYPE_CHAR = string.char FLOAT_TYPE
STRING_TAG = 5
STRING_TAG_CHAR = string.char STRING_TAG
TABLE_REF_TAG = 6
TABLE_REF_TAG_CHAR = string.char TABLE_REF_TAG
TABLE_PAYLOAD_TAG = 7
BLANK_TAG = 8
BLANK_TAG_CHAR = string.char BLANK_TAG
TAG_MASK = 0xf

INT_LEN_SHIFT = 4
INT_LEN_MASK = 0xf

class Serialiser
  new: F '() => <>', =>
    @root_fragments = T '[string]', {}
    @next_ref = T 'number', 0
    @tables = T '[{num_pairs: number, content_fragments: [string]}]', {}
    @refs = T '{table->number}', {}

  @serialise: F '(any) => string', (to_serialise) =>
    Serialiser!
      \write to_serialise
      \finish!

  write: F '(any) => Self', (to_write) =>
    @write_impl to_write, @root_fragments
    @

  write_impl: F '(any, table) => <>', (to_write, fragments) =>
    switch type to_write
      when 'nil'
        fragments[] = NIL_TAG_CHAR
      when 'boolean'
        if to_write
          fragments[] = TRUE_TAG_CHAR
        else
          fragments[] = FALSE_TAG_CHAR
      when 'number'
        if is_float to_write
          fragments[] = FLOAT_TYPE_CHAR
          -- Float support is rudamentary.
          @write_impl (tostring to_write), fragments
          return

        fragments[] = 0 -- Placeholder
        tag_index = #fragments
        while to_write != 0
          fragments[] = string.char bit.band to_write, 0xff
          to_write = bit.brshift to_write, 8

        len = #fragments - tag_index
        assert len <= INT_LEN_MASK
        fragments[tag_index] = string.char bit.bor INT_TYPE,
          bit.blshift len, INT_LEN_SHIFT
      when 'string'
        fragments[] = STRING_TAG_CHAR
        @write_impl #to_write, fragments
        fragments[] = to_write
      when 'table'
        fragments[] = TABLE_REF_TAG_CHAR

        -- Check for already-reached tables
        if ref = @refs[to_write]
          @write_impl ref, fragments
          return

        ref = @next_ref
        @write_impl ref, fragments
        @refs[to_write] = ref
        @next_ref += 1

        content_fragments = {}
        num_pairs = 0
        for k, v in pairs to_write
          num_pairs += 1
          @write_impl k, content_fragments
          @write_impl v, content_fragments
        @tables[] =
          :num_pairs
          :content_fragments
      else
        error "cannot encode #{type to_write}"

  finish: F '() => string', =>
    fragments = {}

    -- Prepare length area.
    fragments[] = '\0' -- Placeholder
    for i = 1, 4
      fragments[] = BLANK_TAG_CHAR

    @write_impl #@tables, fragments
    for table in *@tables
      { :num_pairs, :content_fragments } = table
      @write_impl num_pairs, fragments
      for fragment in *content_fragments
        fragments[] = fragment

    for fragment in *@root_fragments
      fragments[] = fragment

    len = 0
    for fragment in *fragments
      len += #fragment
    len_fragments = {}
    @write_impl len, len_fragments
    if #len_fragments > 5
      error "internal error: len fragments too large #{#len_fragments} > 5"
    for i = 1, #len_fragments
      fragments[i] = len_fragments[i]

    ret = table.concat T '[string]', fragments
    if len != #ret
      error "written len != actual len (#{len} != #{#ret})"
    ret

MAX_INT = switch HOST
  when 'native'
    -- For consistency with Cobalt's small integer width, assume 32-bit max int.
    0x7fffffff
  when 'minecraft'
    0xffffffff
  else
    error "unknown host #{HOST}"
MIN_INT = -MAX_INT - 1

is_float = F '(number) -> boolean', (num) ->
  if num > MAX_INT
    return true
  if num < MIN_INT
    return true

  _, frac = math.modf num
  if frac != 0
    return true

  false

declare_type 'writelite.DeserialiserSource', 'string|writelite.File'
class Deserialiser
  new: F '(writelite.DeserialiserSource) => <>', (@source) =>
    @index = T 'number', 1
    @tables_by_ref = T '{number->table}', {}
    @unresolved_table_refs = T '[{table: table, key: some, ref: number}]', {}

  @deserialise: F '(writelite.DeserialiserSource) => any', (source) =>
    (Deserialiser source)
      \parse!

  @deserialise_raw: F '(string) => any', (source) =>
    (Deserialiser source)
      \parse_value!

  parse: F '() => any', =>
    @raw ??= @prepare_raw!

    total_len = @parse_value!
    if 'number' != type total_len
      error 'internal error: len field is not a number'

    num_tables = @parse_value!
    if 'number' != type num_tables
      error 'internal error: num_tables field is not a number'
    for ref = num_tables - 1, 0, -1
      @parse_table_def ref
    with @parse_value!
      for { :table, :key, :ref } in *@unresolved_table_refs
        value = @tables_by_ref[ref]
        if not value?
          error "internal error: unresolved reference #{ref}"
        table[key] = value

  parse_table_def: F '(number) => {}', (ref) =>
    num_pairs = @parse_value!
    if 'number' != type num_pairs
      error 'internal error: num_pairs field is not a number'

    table = {}
    @tables_by_ref[ref] = table
    with table
      for _ = 1, num_pairs
        key = @parse_value!

        if TABLE_REF_TAG == string.byte @raw, @index
          @index += 1
          ref = @parse_value!
          @unresolved_table_refs[] =
            :table
            :key
            :ref
        else
          [key] = @parse_value!

  parse_value: F '() => any', =>
    @raw ??= @prepare_raw!

    local head
    while true
      head = string.byte @raw, @index
      if not head?
        error "internal error: unexpected EOF at index #{@index}"
      if head != BLANK_TAG
        break
      @index += 1
    @index += 1
    switch bit.band head, TAG_MASK
      when NIL_TAG
        return nil
      when TRUE_TAG
        return true
      when FALSE_TAG
        return false
      when INT_TYPE
        len = bit.band INT_LEN_MASK,
          bit.brshift head,
            INT_LEN_SHIFT

        ret = 0
        for i = 0, len - 1
          ret = bit.bor ret,
            bit.blshift (string.byte @raw, @index),
              i * 8
          @index += 1
        return ret
      when FLOAT_TYPE
        raw = @parse_value!
        if 'string' != type raw
          error "internal error: cannot parse a #{type raw} into float[]"
        return tonumber raw
      when STRING_TAG
        len = @parse_value!
        if 'number' != type len
          error "internal error: cannot use a #{type len} as a string length"
        ret = @raw\sub @index, @index + len - 1
        @index += len
        return ret
      when TABLE_REF_TAG
        index = @index
        ref = @parse_value!
        if 'number' != type ref
          error 'internal error: ref is not a number'
        table = @tables_by_ref[ref]
        if not table?
          error "internal error: ref #{ref} invalid at #{index}"
        return table
      else
        error "unrecognised tag #{bit.band head, TAG_MASK} at index #{@index - 1}"
    error 'unreachable'

  prepare_raw: F '() => string', =>
    switch type @source
      when 'string'
        @source
      else -- writelite.File
        raw_len_bytes, err = @source\read 5 -- Max supported integer size is 1<<32 - 1
        if err?
          error "cannot read length from parse source: #{err}"
        len = Deserialiser::deserialise_raw raw_len_bytes
        if 'number' != type len
          error "cannot use #{type len} as length"
        _, err = @source\seek 'set', 0
        if err?
          error "cannot seek parse source: #{err}"
        raw, err = @source\read len
        if err?
          error "cannot read parse source: #{err}"
        raw

class Page
  new: F '(number, string) => <>', (@_offset, @_content) =>
    @_len = #@_content

  encode: F '() => string', =>
    buf = {}
    @_encode_number @_offset, buf
    @_encode_number @_len, buf
    for byte in *@_content
      buf[] = byte
    string.char unpack buf

MAX_HASH = 99999999 -- 18446744073709551557
assert MAX_INT >= MAX_HASH

declare_type 'writelite.Hasher', [[{
  hash: (any) => number,
  write: (string) => <>,
  finish: () => number,
}]]
class Hasher
  new: F '() => <>', =>
    @_current = 7

  @hash: F '(any) => number', (to_hash) =>
    Hasher!
      \write to_hash
      \finish!

  write: F '(any) => Self', (to_write) =>
    switch type to_write
      when 'boolean'
        if to_write
          @_add 997 * 127
        else
          @_add 997 * 13
      when 'number'
        @_add 997 * (8302197 + to_write)
      when 'string'
        @write 1 + #to_write

        CHUNK_SIZE = 100 -- Limit stack usage
        for i = 1, to_write\len!, CHUNK_SIZE
          start_idx = 1 + (i - 1) * CHUNK_SIZE
          end_idx = i * CHUNK_SIZE
          for byte in *{ to_write\byte start_idx, end_idx }
            @_add 997 * byte
      when 'table'
        entries = with {}
          for key, value in pairs to_write
            [] = :key, :value
        @_add 1 + #entries
        table.sort entries, (a, b) -> a.key < b.key
        for { :key, :value } in *entries
          @write key
          @write value
      else
        error "cannot hash a #{type to_write}"
    @

  _add: F '(number) => <>', (num) =>
    @_current *= num -- % MAX_HASH
    @_current %= MAX_HASH

  finish: F '() => number', =>
    @_current

print_serialised = F '(string) -> <>', (serialised) ->
  indices = [ '%02d'\format i for i = 1, #serialised]
  bytes = with {}
    for i = 1, #serialised
      [] = '%02x'\format serialised\byte i
  is_printable = (c) ->
    'a' <= c and c <= 'z' or
      'A' <= c and c <= 'Z' or
      '0' <= c and c <= '9' or
      c == '-' or
      c == '+' or
      c == '_'
  chars = with {}
    for i = 1, #serialised
      byte = serialised\byte i
      if is_printable string.char byte
        [] = '% 2s'\format serialised\sub i, i
      else
        [] = '%02x'\format byte
  assert #indices == #bytes
  assert #indices == #chars
  PER_LINE = 25
  first = true
  for i = 1, #indices, PER_LINE
    if first
      first = false
    else
      print!
    print table.concat [ i for i in *indices[i, i+PER_LINE-1] ], ' '
    print '-'\rep 3 * (PER_LINE + 1) - 1
    print table.concat [ i for i in *bytes[i, i+PER_LINE-1] ], ' '
    print table.concat [ i for i in *chars[i, i+PER_LINE-1] ], ' '

spec ->
  local *

  import 'spec_macros' as $

  import 'spec' as :clone, :describe, :it, :matchers

  import deep_eq, eq, errors, has_fields, len, lt, matches, near, no_errors, not_ from matchers

  declare_type 'writelite.FileSpec', [[{
    content: string,
  }]]
  class TestFs
    new: F '(?{string->writelite.FileSpec}) => <>', (files={}) =>
      @files = { file, TestFile content for file, { :content } in pairs files }

    open: F '(string, writelite.FileMode) => <?writelite.File, ?string>', (path, mode) =>
      file = @files[path]
      if file?
        file\open!
        file, nil
      else if mode\match '^w'
        file = TestFile ''
        file\open!
        @files[path] = file
        file, nil
      else
        nil, "#{path}: No such file or directory 2"

  class TestFile
    new: F '(string) => <>', (content) =>
      @cursor = 0
      @content_bytes = with {}
        for i = 1, #content
          [] = string.byte content, i
      @closed = true

    open: F '() => <>', =>
      @closed = false

    read: F '("*a"|number) => <?string, ?string>', (amount) =>
      if @closed
        return 'closed'
      end_index = switch amount
        when '*a'
          #@content_bytes
        else
          @cursor + amount
      if end_index > #@content_bytes
        end_index = #@content_bytes
      table.concat [ string.char b for b in *@content_bytes[1+@cursor,end_index] ], nil

    write: F '(string) => ?string', (to_write) =>
      if @closed
        return 'closed'
      for i = 1, #to_write
        @content_bytes[@cursor] = string.byte to_write, i
        @cursor += 1
      nil

    seek: F '(Whence, ?number) => <?number, ?string>', (whence, num) =>
      if @closed
        return nil, 'closed'
      switch whence
        when 'set'
          @cursor = num
        when 'cur'
          @cursor += num
        when 'end'
          @cursor = #@content_bytes + num
        else
          error "internal error: unexpected whence #{whence}"
      @cursor, nil

    setvbuf: F '("full") => <>', (_mode) =>
      if @closed
        error 'closed'

    flush: F '() => <boolean, ?string>', =>
      true, nil

    close: F '() => ?string', =>
      if @closed
        return 'closed'
      @closed = true
      nil

  describe 'writelite.Writelite', ->
    describe '\\mode', ->
      modes = T '[writelite.Mode]'
        * 'blob'

      it 'forbids explicit reassignment', ->
        for mode_a in *modes
          for mode_b in *modes
            print "mode_a=#{mode_a}, mode_b=#{mode_b}"
            writelite = Writelite 'database.db', TestFs!
            writelite\mode mode_a
            $assert_that (-> writelite\mode mode_b), errors matches 'cannot change mode once set'

      -- it 'forbids implicit reassignment', ->
      --   fs = TestFs!
      --   writelite1 = with Writelite 'database.db', fs
      --     \mode 'blob'
      --   -- TODO(kcza): write a database to an FS with mode A, close, open again with mode B, where A != B

    describe '\\page_size', ->
      it 'forbids explicit reassignment', ->
        writelite = Writelite 'database.db', TestFs!
        writelite\page_size MIN_PAGE_SIZE
        $assert_that (-> writelite\page_size MIN_PAGE_SIZE), errors matches 'cannot change page size once set'

      it 'forbids too-small page sizes', ->
        with Writelite 'database.db', TestFs!
          $assert_that (-> \page_size MIN_PAGE_SIZE - 1), errors matches "cannot change page size to #{MIN_PAGE_SIZE - 1}: minimum is #{MIN_PAGE_SIZE}"

      it 'requires integers', ->
        with Writelite 'database.db', TestFs!
          $assert_that (-> \page_size 1234.5), errors matches 'cannot change page size to 1234%.5: not an integer'

      it 'requires powers of two', ->
        for i = 10, 30
          print "testing #{i}..."
          with Writelite 'database.db', TestFs!
            $expect_that (-> \page_size bit.blshift 1, i), no_errors!

        with Writelite 'database.db', TestFs!
          $expect_that (-> \page_size 2000), errors matches 'cannot change page size to 2000: not a power of 2'

      it 'forbids implicit reassignment', ->
        fs = TestFs!
        with Writelite 'database.db', fs
          \mode 'blob'
          \page_size bit.blshift 1, 13
          _, err = \open!
          $assert_that err, eq nil
          _, err = \close!
          $assert_that err, eq nil
        with Writelite 'database.db', fs
          \mode 'blob'
          \page_size bit.blshift 1, 20
          ok, err = \open!
          $expect_that ok, eq false
          $expect_that err, matches 'page size mismatch'

    describe '\\open', ->
      it 'requires mandatory metadata', ->
        metadata =
          * name: 'mode'
            action: (wl) -> wl\mode 'blob'
            expect: 'cannot open main file: mode unspecified'
          * name: 'page size'
            action: (wl) -> wl\page_size bit.blshift 1, 13
        for index_to_omit = 1, #metadata
          { :name, :expect } = metadata[index_to_omit]
          print "testing omission of #{name}..."

          writelite = Writelite 'database.db', TestFs!

          for i = 1, #metadata
            if i == index_to_omit
              continue
            metadata[i].action writelite

          if expect?
            ok, err = writelite\open!
            $expect_that ok, eq false
            $expect_that err, matches expect
          else
            ok, err = writelite\open!
            $assert_that ok, eq true
            $assert_that err, eq nil

            ok, err = writelite\close!
            $assert_that ok, eq true
            $assert_that err, eq nil

      it 'cannot be called whilst open', ->
        with Writelite 'database.db', TestFs!
          \mode 'blob'
          ok, err = \open!
          $expect_that ok, eq true
          $assert_that err, eq nil

          ok, err = \open!
          $expect_that ok, eq false
          $assert_that err, matches 'cannot open writelite file twice'

          ok, err = \close!
          $expect_that ok, eq true
          $assert_that err, eq nil

          ok, err = \open!
          $expect_that ok, eq true
          $assert_that err, eq nil

          ok, err = \open!
          $expect_that ok, eq false
          $assert_that err, matches 'cannot open writelite file twice'

    describe '\\close', ->
      it 'cannot be called twice', ->
        with Writelite 'database.db', TestFs!
          \mode 'blob'
          ok, err = \open!
          $assert_that ok, eq true
          $expect_that err, eq nil

          ok, err = \close!
          $assert_that ok, eq true
          $assert_that err, eq nil

          ok, err = \close!
          $assert_that ok, eq false
          $assert_that err, eq 'cannot close writelite file: not open'

    describe 'consistency', ->
      tests =
        * failure_point: 'pre-verification'
          expect_after_failed_run: (initial_fs, current_fs) ->
          expect_after_second_run: (initial_fs, current_fs) ->
      known_failure_points = $known_failure_points!
      for test in *tests
        { :failure_point, :expect_after_failed_run, :expect_after_second_run } = test
        it "is maintained at #{failure_point} failure", ->
          if not known_failure_points[failure_point]?
            error "no such failure point '#{failure_point}'"

          fs = TestFs!

          -- Prepare fresh, empty database.
          with Writelite 'database.db', fs
            \mode 'blob'
            assert \open!
            assert \close!

          $assert_that fs.files, has_fields
            ['database.db']: not_ eq nil
            ['database.db~']: eq nil

          -- initial_fs = clone fs
          --
          -- try
          --   with Writelite 'database.db', fs
          --     \mode 'blob'
          --     \_ut_inject_failures
          --       [failure_point]: true
          --
          --     ok, err = \open!
          --     \transaction (txn) ->
          --       -- TODO(kcza): complete me once the journal is ready.
          --     ok, err = \close!
          -- catch err2
          --   if err2 != $failure_marker!
          --     err = err2
          -- $assert_that err, eq nil
          --
          -- expect_after_failed_run initial_fs, fs
          --
          -- try
          --   with Writelite 'database.db', fs
          --     \mode 'blob'
          --     assert \open!
          --     assert \close!
          -- catch err2
          --   if err2 != $failure_marker!
          --     err = err2
          -- $assert_that err, eq nil
          --
          -- expect_after_second_run initial_fs, fs

  describe 'writelite.Hasher', ->
    it 'avoids collisions', ->
      collisions = {}
      NUM_STRINGS = 10000
      for i = 1, NUM_STRINGS
        hash = Hasher!
          \write "some_string_#{i}_which_is_similar"
          \finish!
        collisions[hash] ??= 0
        collisions[hash] += 1

      max_collisions = -1
      for h, c in pairs collisions
        if max_collisions < c
          max_collisions = c
      $expect_that max_collisions, lt NUM_STRINGS * 0.01

    it 'is stable for tables', ->
      make_test_data = ->
        with {}
          .k1 =
            k11: 'a'
            k12: 'b'
          .k2 =
            k21: 'c'
            k22: 'd'
      hash = nil
      for i = 1, 1000
        h = Hasher!
          \write make_test_data!
          \finish!
        if hash?
          $assert_that h, eq hash
        else
          hash = h

  describe 'writelite.Serialiser roundtrip', ->
    tests =
      * name: 'nil'
        value: nil
      * name: 'true'
        value: true
      * name: 'false'
        value: false
      * name: 'int (zero)'
        value: 0
      * name: 'int (small, positive)'
        value: 10
      * name: 'int (small, negative)'
        value: -10
      * name: 'int (max int)'
        value: MAX_INT
      * name: 'int (min int)'
        value: MIN_INT
      * name: 'float (small positive)'
        value: 1.1
        check: (actual, value) ->
          $expect_that actual, near value
      * name: 'float (small negative)'
        value: -1.1
        check: (actual, value) ->
          $expect_that actual, near value
      * name: 'float (large positive)'
        value: 9999999999999 * 9999999 * 0.3
        check: (actual, value) ->
          $expect_that actual, near value
      * name: 'float (large negative)'
        value: -9999999999999 * 9999999 * 0.3
        check: (actual, value) ->
          $expect_that actual, near value
      * name: 'empty string'
        value: ''
      * name: 'short string'
        value: 'asdf'
      * name: 'long string'
        value: 'x'\rep 1000
      * name: 'simple leaf table'
        value:
          [false]: true
      * name: 'simple leaf table'
        value:
          hello: true
      * name: 'simple leaf table'
        value:
          [false]: 'world'
      * name: 'complex leaf table'
        value:
          hello: 'world'
      * name: 'tree table'
        value:
          hello:
            world:
              how:
                are: 'you'
      * name: 'cyclic table'
        value: do
          ret = {}
          ret.self = ret
          ret
      * name: 'indirectly cyclic table'
        value: do
          ret = child: {}
          ret.child.parent = ret
          ret
      * name: 'key-tree-table'
        value:
          [hello: 'there']: 'world'
        check: (actual, value) ->
          actual_structure = [ :key, :value for key, value in pairs actual ]
          for kv in *actual_structure
            kv.key = [ :key, :value for key, value in pairs kv.key ]
          $expect_that actual_structure, deep_eq {{
            key:
              * key: 'hello'
                value: 'there'
            value: 'world'
          }}
      * name: 'key-cyclic table'
        value: do
          ret = {}
          ret[ret] = true
          ret
        check: (actual, value) ->
          keys = [ :key for key, _ in pairs actual ]
          $assert_that keys, len eq 1

          { { :key } } = keys
          $expect_that key[key], eq true
      -- TODO(kcza): support indirectly key-cyclic tables

    for test in *tests
      {
        :name
        :value
        :matcher=deep_eq
        :check=(actual, value) ->
          $expect_that actual, deep_eq value
      } = test
      it "works for #{name}", ->
        serialised = Serialiser!
          \write value
          \finish!

        serialised_directly = Serialiser::serialise value
        $expect_that serialised_directly, eq serialised

        print_serialised serialised
        deserialised_from_string = (Deserialiser serialised)
          \parse!
        check deserialised_from_string, value

        direct_deserialised_from_string = Deserialiser::deserialise serialised
        check direct_deserialised_from_string, value

        path = os.tmpname!
        file = assert io.open path, 'w+'
        with file
          assert \write serialised
          assert \flush!
          assert \seek 'set', 0

          local err

          try
            deserialised_from_file = (Deserialiser file)
              \parse!
            check deserialised_from_file, value
          catch err2
            err = err2
          if err?
            error err

          assert \seek 'set', 0
          try
            direct_deserialised_from_file = Deserialiser::deserialise file
            check direct_deserialised_from_file, value
          catch err2
            err = err2
          if err?
            error err

          assert \close!
        os.remove path
