local *

import 'quicktype' as :declare_singleton_type, :declare_type, :F
import 'spec' as :spec

declare_type 'writelite.Writelite', [[{
  transaction: ((writelite.Transaction) -> <>) => <>,
  close: () => <>,
}]]
export class Writelite
  new: F '(string, writelite.File) => <>', (@_path) =>
    @_journal_path = @_path .. '~'
    @_main_file = with assert io.open @_path, 'w+'
      \setvbuf 'full' -- Minimise writes.
    @_writelite_open = true
    @_transaction_open = false

    if journal = io.open @_journal_path, 'r'
      @_recover_journal @_main_file, journal

  _recover_journal: F '() => <>', =>
    -- TODO(kcza): Only if valid!
    error 'todo'

  transaction: F '((writelite.Transaction) -> <>) => <>', (f) =>
    @_transaction_open = true

    txn = Transaction @_main_file, @_journal_path
    err = nil
    try
      f txn
    catch err2
      err = err2
      txn\abort!
    txn\_close!

    @_transaction_open = false

    if err?
      error err
    return

  close: F '() => <>', =>
    assert not @_transaction_open, 'cannot close Writelite whilst transaction is open'
    assert @_writelite_open, 'cannot close Writelite twice'

    @_main_file\close!

    @_writelite_open = false

PAGE_SIZE = 4096

WRITELITE_PRELUDE = do
  prelude_fragments =
    * '\n'
    * '\n'
    * '\n'
    * '\n'
    * 'STOP!\n'
    * '\n'
    * 'DO NOT EDIT!\n'
    * '\n'
    * 'Editing this file will corrupt the database.\n'
    * '\n'
    * 'Close this file and DO NOT SAVE any changes.\n'
    * '\n'
    * 'EXIT the editor NOW.\n'
    * '\n'
    * '\n'
    * '\n'
    * '\n'
  prelude_len = 0
  for line in *prelude_fragments
    prelude_len += #line

  spacer_line = ('.'\rep 49) .. '\n'
  while prelude_len < PAGE_SIZE - #spacer_line
    prelude_fragments[] = spacer_line
    prelude_len += #spacer_line

  while prelude_len < PAGE_SIZE - 2
    prelude_fragments[] = '.'
    prelude_len += #'\n'
  prelude_fragments[] = '@'
  prelude_fragments[] = '\n'

  prelude = table.concat prelude_fragments
  assert #prelude == PAGE_SIZE
  prelude

declare_type 'writelite.Transaction', [[{
  write: (string) => <>,
  seek: (Whence, ?number) => <>,
  abort: () => <>,
}]]
declare_type 'writelite.File', [[{
  write: (string) => <>,
  seek: (Whence, ?number) => <>,
  close: () => <>,
}]]
declare_type 'Whence', '"set"|"cur"|"end"'
class Transaction
  new: F '(writelite.File, string) => <>', (@_main_file, @_journal_path) =>
    @_pages = T '[writelite.Page]', {}
    @_len = T 'number', 0
    @_cursor = T 'number', 0
    @_aborted = T 'boolean', false

    @_journal_file = T 'writelite.File', with assert io.open @_journal_path, 'w+'
      \setvbuf 'full' -- Minimise writes.

  write: F '(string) => <>', (bytes) =>
    if @_aborted
      error 'cannot write to aborted transaction'

    @_len += #bytes
    for bytes_offset = 0, #bytes, Page.SIZE
      @_pages[] = Page @_cursor, bytes\sub 1 + bytes_offset, 1 + bytes_offset + PAGE_SIZE
      @_cursor += PAGE_SIZE
    error 'todo'

  seek: F '(Whence, ?number) => <>', (whence, offset) =>
    if @_aborted
      error 'cannot seek in aborted transaction'

    switch whence
      when 'set'
        @_cursor = offset ?? 0
      when 'cur'
        assert offset?, 'internal error: "cur"-whence requires offset'
        @_cursor += offset
      when 'end'
        assert not offset?, 'internal error: "end"-whence cannot have no offset'
        @_cursor = @_len
      else
        error 'internal error: unreachable'

  abort: F '() => <>', =>
    @_aborted = true

  _close: F '() => <>', =>
    if @_aborted
      -- TODO(kcza): figure out how to NOT write the journal if a power
      -- failure occurs after an abort but before the journal is removed.
      os.remove @_journal_path

    -- Write to journal
    for page in *@_pages
      @_journal_file\write page\encode!
    @_journal_file\close!

    -- Write to main file
    for page in *@_pages
      @_main_file\seek 'set', page._offset
      @_main_file\write page._content
    @_main_file\flush!

    -- Delete journal
    os.remove @_journal_path
    error 'todo'

class Page
  new: F '(number, string) => <>', (@_offset, @_content) =>
    @_len = #@_content

  encode: F '() => string', =>
    buf = {}
    @_encode_number @_offset, buf
    @_encode_number @_len, buf
    for byte in *@_content
      buf[] = byte
    string.char unpack buf

  encode_number: F '(number, [number]) => <>', (number, buf) =>
    for i = 1, 8
      [] = number % 256
      number /= 256

  decode: F '(string) => <>', (raw) =>
    error 'todo'

  decode_number: F '(string, number) => number', (buf, index) =>
    bytes = { string.char buf\sub index, index + 8 }
    ret = 0
    base = 1
    for byte in *bytes
      ret += base * byte
      base *= 256
    ret

spec ->
  import 'spec_macros' as $

  import 'spec' as :describe, :it, :matchers

  import eq from matchers

  describe 'Writelite', ->
    it 'does things', ->
      $expect_that true, eq false
